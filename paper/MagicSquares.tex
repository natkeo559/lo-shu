% chktex-file 44
% chktex-file 29
\documentclass{rhumj_new}

%\title[short title (for header)]{full title}
\title[Magic Squares]{An Approach to Computing Magic Squares Using High-Performance Computing and
  Group Theory}

%\author[short author name (for header)]{author name}
%\affiliation{author affiliation}
%\email{author email}

\author[Keough]{Nathan H. Keough\thanks{Thanks to all who encouraged and supported me.}}
\affiliation{Maryville College}
\email{nathan.keough@my.maryvillecollege.edu}

%additional authors; list in alphabetical order by last name
% \author[Euler]{Leonard Euler\thanks{Thanks for nothing, Bernoulli.}}
% \affiliation{University of Basel}
% \email{oiler@notmail.com}

%please include 2010 mathematics subject classification:
%https://mathscinet.ams.org/msc/msc2010.html
% Computer science {For papers containing software, source code, etc. in a specific mathematical area, see the classification number –04 in that area}
\subjclass{68V99}
%please provide keywords for your article
\keywords{magic squares, computational group theory, rust}

%\abstract{A brief abstract goes here.}

\begin{document}
\abstract{This paper introduces a novel algorithm for computing magic squares, exploiting
  group theory concepts such as permutation representation, group operations, and group actions to
  encode symmetries. By defining the group operation as composition, the set as a subset of the
  group of magic squares in a specific order, we may systematically explore the permutations of the
  group and extrapolate information about the magic squares to generate new magic squares not in
  the originating set. This vastly reduces computation times for enumerating the solutions to magic
  squares, while also encoding the symmetries in a manner that is easier to analyze
  programmatically. Overall, this study reveals the profound connection between magic squares and
  group theory, offering promising avenues for symmetry-driven algorithms and applications in
  combinatorial mathematics.}

\section{Introduction}

The secrets behind magic squares have engaged mathematicians for millennia. The magic square
problem itself is believed to have originated in China around 2200 BCE with the introduction of
what are now known as “Lo-Shu” magic squares. These magic squares are defined as $3\times3$ grids
with the numbers $1$ through $9$ arranged such that the sums of all the rows, columns, and
diagonals are the same. Note in that the rows, columns, and diagonals each
add to $15$.

This property is what makes a square ``magic,'' lending a connotation of power that is
respected by many ancient cultures. In many ways, magic squares have held a mythical reputation in
culture due to their unique properties. As mathematics evolved, so did the study of magic squares
worldwide, later appearing in India, The Middle East, and Latin Europe. Each rendition of the magic
square problem brings with it new questions in mathematics. The number of solutions to the Lo-Shu
magic square problem is well known. However, The number of solutions to other kinds of squares
remains a great mystery, especially as the size of the square grows.

Today, magic squares hold less of a mythical and powerful cultural reputation. Mathematics, at
this point in history, has been able to deduce new and creative uses for magic squares in various
different fields, especially physics. In 2021, scientists found a connection between electrostatic
potentials and magic squares of the $4^{th}$ and $5^{th}$ order [Fahimi]. Similarly, magic squares
of the $6^{th}$ order have been associated with the Weak Force in physics [ONeill]. Outside of
physics, there are also uses for magic squares in image encryption, specifically, using large
squares as chaos maps in chaos-based encryption schemes [Wang]. For these reasons and many others,
the continual study of magic squares carries with it the possibility of new breakthroughs in
applied mathematics.

Although there are many kinds of magic squares, we will only interest ourselves in ``normal''
magic squares, which have two main requirements: $(1)$ The square must be filled with the integers
from $1$ to $n^2$ inclusive, where $n$ is the order of the magic square, and $(2)$ the sums of the
main columns, rows, and diagonals must equal the same integer. This integer $S$ is called the
``magic sum'' and is calculated by $nS = \frac{n^2(n^{2}+1)}{2}$ with the right-hand side equating
to the sum of the first $n^2$ positive integers, and the left-hand side equal to the magic sum
multiplied by a factor $n$, the order of the square. Dividing by this factor on both sides
satisfies this equation for the magic sum. The number of rows, columns, and diagonals is equal to
$2n+2$ with $n$ being the order of the square. This is considered the number of ``constraint
vectors'' of a magic square.

We are also only interested in studying ``unique'' magic squares. By this, we mean magic
squares that are unique up to rotations and reflections or isometry. An example of this is taking a
magic square $A$ and rotating it $90^{\circ }$ or reflecting it about the y-axis any number of
times. The resulting square will always be considered equivalent to $A$. There may also be times
when we refer to a ``positionally distinct'' magic square. In this case, isometries of a magic
square $A$, result in a ``different'' square $B$. Neither of these definitions affect the validity
of magic squares; they only affect how we count them. Fig.***** accurately represents
two magic squares that we would consider to be the ``same'' square up to isometry.

There is only one unique solution for the Lo-Shu Square, pictured in Fig.*****.
There are extensions to the magic square problem, with variants having larger side lengths (order),
different ``magic'' requirements, or different kinds of element values. For order four, there are
$880$ unique solutions. For order five, there are $275,305,224$ unique solutions [Fahimi]. However,
the number of exact unique solutions for order six remains unknown. The number of unique solutions
for each order exhibits a kind of exponential growth, and their values have been of interest to
mathematicians and hobbyists since the puzzle's inception.

\subsection{Permutations}

The main mechanism that we use for encoding a magic square and its properties comes from Group
and Number Theory. Specifically, we will study the permutations of magic squares. In the 1770s,
Joseph Louis Lagrange studied permutations of the roots of polynomial equations. This led to Galois
theory founded by Évariste Galois, which describes what is or is not possible with respect to
solving polynomial equations by radicals [Fraser]. In modern mathematics, there are many similar
situations where studying permutations can help us understand a problem.

Roughly speaking, magic squares may be represented as permutations of $n^2$ objects. By the
definition of a normal magic square, these are the positive integers (mod $n^2$). The dimension
need not matter since the coordinates of elements in a two-dimensional, row-major grid square may
be mapped to a one-dimensional sequence, which is a bijection. The square, laid out as a
one-dimensional sequence, represents the sequence of integers as a permutation. There are a total
of $n^{2}$! permutations of a square, where $n$ is the order of the square. The permutations of
squares represent the different possible configurations of integers in the square, many of them
meeting the requirements to be considered magic squares.

The concept of interpreting grid squares as permutations may be realized by
Fig.***** where the set $S = \{a, b, c, d, e, f, g, h, i\} \in S_9$. By decomposing
the rows of an $n\times n$ square into an ordered set containing all elements from $1\cdots n^2$,
we may consistently map the set to unique permutations on $n^2$ objects.

We believe that by studying different permutations of squares, including those that are magic,
we may be able to describe various kinds of symmetry related to magic squares of specific orders.
Treating individual squares as permutations and vice-versa allows us to make use of the properties
relating to permutations in general, meaning we can perform unique transformations or actions on
them using methods originating from group theory. Additionally, we may define other mathematical
properties that allow us to better describe magic squares and their associated symmetries that go
beyond simple row and column transposition.

\subsection{Enumeration}

In our investigation into the inner structures and symmetries of magic squares, we may find it
useful to enumerate the magic squares, i.e.\ exhaustively listing and analyzing every magic square
of a specific order. By hand, this is difficult, but with high performance programming, we can do
this very easily for certain orders and with certain algorithms. Prior to modern computing,
mathematicians were computing large orders by hand using various methods. Some in particular
developed by W.S. Andrews in 1908 utilized ``constructions'', whereby assumptions about initial
known values are used to help complete a magic square using some algorithmic process, potentially
cutting down on the total amount of computation [Andrews]. Some aspects of constructions are
similar to the method outlined in this paper but with some differences. Our method makes no
assumptions about initial values, but some code exists that could support constructive methods of
magic square generation. Listing magic squares in this way, as we will see, is useful and allows us
to generalize certain properties of magic squares, potentially also for higher orders.

Recall that the number of permutations of $n$ objects is $n$!. We can actually exploit this
fact to implement an element of ordering for magic squares. There exists a natural ordering from
$S_n$, the group of all permutations on $n$ elements, to $\mathbb{Z}^{*}_{n!-1}$  in the
factor-adic number system, (*) meaning non-negative. This number system, also known as the
factorial number system, is a mixed radix adapted for combinatorial systems. In this system, we can
express the permutations of $n$ objects in lexicographical order, that is naturally from $0$ to
$n!-1$ as a bijection. Using the factor-adic number system's properties we can treat magic squares
(or any grid square) as a permutation, and map that permutation uniquely to an integer. More
generally, this concept is called a Lehmer Encoding of a permutation on $n$ integers [Lehmer]. This
not only simplifies our intuition of what a unique magic square looks like, but also improves the
performance of a magic square computation in some cases, specifically, the cost of copying integers
over whole arrays and storing magic squares in memory.

It should be noted that the indices of magic squares in their ordered set do not follow an
easily identifiable pattern. Perhaps there is a pattern, but we have no way of identifying it based
on our current assumptions of magic squares. In any case, analyzing the frequency of magic squares
in their ordered set has not so far proved to be helpful. Exhaustive enumeration of magic squares
is presumed to be an NP-Hard problem, making it suitable for certain cryptographic applications.
However, it is at least NP;\@ the NP-completeness and classification of the magic square problem is
formally unknown. For context, P versus NP is an unsolved problem in theoretical computer science
and is a millennium prize problem. A problem classified as P is solvable and verifiable in
polynomial time with respect to its input size. Problems in NP are verifiable in polynomial time.
Solving if P = NP would mean that problems verifiable in polynomial time are solvable in polynomial
time. A problem X in NP is considered NP-complete if and only if any other problem in NP is
reducible to X. The class of NP-Hard problems contains all NP-Complete problems but also includes
those that are undecidable. The theoretical complexity of predicting magic squares is unknown, yet,
there do exist applications in artificial intelligence for predicting and classifying magic squares
  [Weed]. The role of artificial intelligence in mathematics is becoming increasingly apparent.
Opting for AI-driven solutions could be a great approach for future studies.

\section{Computational Approach}

\subsection{Introduction}

To help us compute magic squares, we have implemented a custom Computational Algebra System
(CAS) written in the Rust Programming Language. This system allows us to construct and manipulate
square data to find magic squares. Once we have magic squares, we may do additional processing on
them to learn more about their structures. The system is geared for high performance and thus
implements some of the best known strategies for working with magic square structures, both
mathematically and programmatically.

All implementations are justified through the use of a benchmark-driven software development
policy, meaning certain implementations or algorithms are added, used, and possibly modified
modified based on benchmarking and profiling results. This, of course, is highly dependent on the
hardware being used. Our specific hardware being used to quantify and express the results of
computed magic squares includes:

\begin{itemize}
  \item AMD Ryzen 7 5800X x8 (16) @ 4.200GHz, 32GB RAM \textemdash{}  Pop!\_Os 22.04 LTS x86\_64
  \item Apple M2 x8 (8) (x4 performance, x4 efficiency) @ 3.500GHz, 24GB RAM \textemdash{} macOS
        13.3.1
        22E261 ARM64
\end{itemize}

\subsection{Modern Design Patterns}

The decision to use Rust follows three main selling points despite any perceived controversy
or opinions regarding the novelty of the language. While the Rust Programming Language is
relatively new compared to other languages such as C/C++ or Python, Rust comes with the benefit of
over 40 years of hindsight with respect to modern software development practices. Additionally,
Rust offers a high degree of performance out of the box, which was something we specifically
required due to the scale of our computations. Finally, using Rust provides our software with a
great deal of flexibility as we can create low-level solutions using high-level interfaces. We also
save quite a bit of time in development due to the lack of trivial memory bugs, representable
invalid states, and time spent manually scripting complex build processes.

Our code, written entirely from scratch, implements many strategies for working with
permutations, including their enumerations. Given that our code is being used in a scientific
context, special emphasis was placed on making the code's interface as usable as possible without
missing out on performance. In Rust, this is easy to guarantee through a process called ``Bounded
Parametric Polymorphism'' wherein we can monomorphize for various arbitrary but constrained
parameter sets containing constants, where the constants feed generic types evaluated at compile
time [Luca]. In our case, these parameter sets hold metadata for specific magic square orders and
drive the overall behavior of the code. This improves the performance greatly, but increases
compile times and binary sizes \textemdash{} a necessary tradeoff to maximize the performance
potential
of our code. The resulting code appears generic and agnostic to magic square order.

\subsection{High-Performance Computing}

Applying high-performance computing paradigms to our code vastly improves both the quality and
efficiency of our computations. We implemented three main strategies for improving the performance
of our code. These are Multi-threading, Single Instruction Multiple Data (SIMD), and
implementations of Message Passing Interfaces (MPI).

We tested many strategies for implementing multi-threading and compared each one through the
use of benchmarks and profiling. In our benchmarks we found that using multi-threading improved
brute-force performance of order three magic squares by about 91.12\% on average. This resulted in
a total computation time of 1.03 ms. Combined with trivial set reduction, multi-threading resulted
in computation times of about 349.60 µs. This is a massive improvement over standard brute-force
iteration. In addition we found that certain thread management strategies tend to produce better
performance benchmarks. We concluded that non-linear partitioning of thread data and reduction of
shared memory resulted in 29.79\% better performance on average.

We implemented SIMD for certain highly parallelizable tasks such as magic square validity
checking. This is a somewhat niche optimization that exists on the specific hardware we are using.
We interact with the CPU architecture through the use of intrinsics to manage specific registers
that operate in parallel so that we may process a higher throughput of data. The alternative to
using SIMD registers is to use scalar CPU operations. We compared the performance of both scalar
and vector code. We found that the performance gained from using SIMD intrinsics was negligible
compared to scalar code. We also encountered some inconsistencies attributable to environment and
hardware related caveats that are difficult to control for. Overall, we concluded that SIMD would
most likely benefit from operating on larger streams of data than how they are being used
currently, thus possibly having more influence on benchmarks for magic square orders greater than
four. In hindsight, it still makes sense to target checking for optimizations since it takes about
six times more time to check an arbitrary square than it does to generate new permutations (101.8
ns vs. 16.7 ns).

We alse implemented a form of message passing in Rust that utilizes a Multiple Producer Single
Consumer (MPSC) Queue to better manage threads performing parallel computations on magic squares.
We tested multiple strategies regarding thread management and found that MPSC thread management
also benefits from partitioning and reduction of shared state concurrency. Each ``producer'' in the
context of MPSC is non-blocking and does not interact with the other threads. The ``consumer''
feeds a continuous stream of solved magic squares to the main thread and is also non-blocking. This
results in vast performance improvements for computing magic squares using brute-force. The MPSC
system we implemented solved the entire set of order three magic squares in about 243.64 µs. This
method will be our primary method for brute-force computing magic squares in parallel.

\subsection{Additional Features}

In addition to the high-performance aspects of our code, we've also added features that would
be useful to other scientists exploring magic squares. Additional features include the ability to
log or serialize computations to files, encode magic sqaures in compressed formats, implement
parameter sets defining large-order squares, use contructive methods, and run examples with
extensive documentation. The code itself is structured as a crate or library, so given sufficent
interest, it can be readily published. Alternatively, all of the code is on GitHub [Keough].

% \section{The title of the second section}
% The class file contains definitions for several environments (e.g., {\ttfamily thm, corollary,
%     lemma}, etc). Examples follow below.

% Important definitions should be set in the \texttt{defin} environment.
% \begin{defin}\label{prim-def}
%   Let $p \in \mathbf{N}$ and suppose the following hold:
%   \begin{itemize}
%     \item[\sffamily\bfseries P1.] If $d \in \mathbf{N}$ such that $d \mid p$, then $d = 1$ or $d=p$.
%     \item[\sffamily\bfseries P2.] $p \neq 1$.
%   \end{itemize}
%   Then we say that $p$ is a \emph{prime number}.
% \end{defin}

% Use the \texttt{label} command for reference to these environments later on in your document. The
% class file uses the \texttt{cleveref} package which determines the type of label being referenced:
% \begin{center}
%   \begin{tabular}{lcr}
%                          & \LaTeX\ code                              & Result          \\
%     \hline
%     Using \texttt{ref}:  & \verb|\textbf{definition \ref{prim-def}}| &
%     \textbf{definition~\ref{prim-def}}                                                 \\
%     Using \texttt{cref}: & \verb|\cref{prim-def}|                    & \cref{prim-def}
%   \end{tabular}
% \end{center}

% %an example of the lemma environment
% \begin{lemma}\label{baby-ftoa}
%   If $n \in \mathbf{N}$, then there exists a prime number $p$ such that $p \mid n$.
% \end{lemma}

% \begin{proof}
%   Suppose, for contradiction, that there exists $n \in \mathbb{N}$ such that $n >1$ and $n$ is not
%   divisible by any prime. Let
%   \[ S = \{ n \in \mathbf{N}: n>1,\ \text{$n$ is not divisible by a prime}\}.\]
%   Then $S$ is a non-empty subset of $\mathbf{N}$. The well-ordering principle\footnote{An excellent
%     principle.} fashions a least element of $S$, say $m$. Note that $m$ is not prime (otherwise it
%   would be divisible by a prime, namely itself). Since $m$ is not prime, there exists $a \in
%     \mathbf{N}$ such that $a \mid m$ and $a \neq 1$ and $a \neq m$. Let $b \in \mathbf{Z}$ such that
%   $ab = m$. Note that $b \in \mathbf{N}$ since $a,m \in \mathbf{N}$. What's more, $b >1$ since
%   otherwise $a=m$. So it must be that $1 < a,b < m$. Since divisibility is transitive, it follows
%   that neither $a$ nor $b$ is divisible by a prime. But then $a \in S$ (and so is $b$) and $a  = m/b
%     < m$ contradicting the minimality of $m$. Thus it must be that $S$ is empty which proves the lemma.
% \end{proof}

% %an example of the thm environment
% \begin{thm}[Euclid] There are infinitely many prime numbers.
% \end{thm}\label{inf-prim}

% \begin{proof}
%   Let $p_1,p_2,\ldots, p_k$ be primes, and let
%   \[ n = p_1p_2 \cdots p_k + 1.\]
%   By \cref{baby-ftoa}, there exists a prime $p$ such that $p \mid n$. Suppose, for contradiction,
%   that $p = p_i$ for some $i=1,2,\ldots, k$. It follows that $p \mid n-p_1p_2\cdots p_k = 1$, but
%   this is absurd. So it must be that $p \neq p_i$ for any $i = 1,2,\ldots k$. This shows that a new
%   prime can be constructed from any finite list of primes. Hence the number of primes is not finite.
% \end{proof}

% Use the \texttt{cite} command to cite references. For example, the above proof can be found in
% Euclid's Elements~\cite{elements}. See below for how to add citations to the
% \texttt{thebibliography} environment.

% \section{A title for the third section}

% There is an \texttt{example} environment.

% \begin{exa}\label{geo-series} The geometric series
%   \[ \sum_{k=0}^{\infty} \frac{1}{2^k} \]
%   converges to $2$.
% \end{exa}

% When starting a sentence with a reference, use the \texttt{Cref} command. \Cref{geo-series} can be
% used to prove that $2$ is not the only prime.

% \begin{thm}\label{more-primes} The set of primes includes more numbers than just $2$.
% \end{thm}

% \begin{proof}
%   If $2$ were the only prime number, then the fundamental theorem of arithmetic would give us that
%   \[ \sum_{n=1}^{\infty} \frac{1}{n} = \sum_{k=0}^{\infty} \frac{1}{2^k}.\]
%   The series on the left diverges whereas the series on the right converges. This is impossible, so
%   there must be more prime numbers beyond the number $2$.
% \end{proof}

% There is a \texttt{remark} environment as well.

% \begin{remark} The idea in \cref{more-primes} can be extended to show that the set of primes
%   includes more numbers than just $2$ and $3$. In fact, Euler went on to prove that if the number of
%   primes were finite, then the harmonic series would converge.
% \end{remark}

% \section{A title for the fourth section}

% There are \texttt{prop} and \texttt{corollary} environments as well.

% \begin{prop}\label{sqr-decomp} Every natural number can be written uniquely as a product of a
%   square-free number and a square.
% \end{prop}

% As a corollary to \cref{sqr-decomp} we obtain

% \begin{corollary}\label{low-bound} Let $\pi(n)$ denote the number of primes less than or equal to
%   $n$. Then
%   \[ \pi(n) \geq \frac{\log n}{2\log 2}.\]
% \end{corollary}

% \begin{proof} There are no more than $2^{\pi(n)}$ square free numbers less than $n$. Also, there
%   are no more than $\sqrt{n}$ squares less than $n$. It follows from \cref{sqr-decomp} that
%   \[ n \leq 2^{\pi(n)} \sqrt{n}.\]
%   The corollary follows by applying log.
% \end{proof}

% For an unnumbered remark, use the \texttt{xrem} environment.
% \begin{xrem} Note that \cref{low-bound} implies that there are infinitely many primes.
% \end{xrem}

\begin{thebibliography}{10}

  %items in the bibliography should be listed in alphabetical order
  %in order to ensure that your reference is formatted correctly, do the following:
  %   1) Visit mathscinet to find your citation; for example, search author=euclid, title=elements. Click on the citation
  %   2) Copy (ctrl-c) the reference from mathscinet; for example:
  %Euclid
  %Euclid's Elements.
  %All thirteen books complete in one volume. The Thomas L. Heath %translation. Edited by Dana Densmore. Green Lion Press, Santa Fe, %NM, 2002. xxx+499 pp. ISBN: 1-888009-18-7; 1-888009-19-5
  %01A75 (01A20 01A60 51-03)
  %   3) paste (ctrl-v) the reference into mref %https://mathscinet.ams.org/mref
  %   4) click search, then click TeX
  %   5) copy/paste the TeX code from mref as shown below:

  \bibitem{elements}
  Euclid, {\it Euclid's {\it Elements}}, the Thomas L. Heath translation, Green Lion Press, Santa
  Fe,
  NM, 2002. MR1932864

  \bibitem{diff-calc}
  Euler, {\it Foundations of differential calculus}, translated from the Latin by John D. Blanton,
  Springer-Verlag, New York, 2000. MR1753095

  \bibitem{eulogy}
  P. G. L. Dirichlet, Ged\"{a}chtni\ss{} rede auf Carl Gustav Jacob Jacobi, in {\it Nachrufe auf
      Berliner Mathematiker des 19. Jahrhunderts}, 6--34, Teubner-Arch. Math., 10, Teubner,
  Leipzig.
  MR1104895

\end{thebibliography}

\end{document}